<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Video Transcript to HTML Convertor</title>
</head>
<body>
	<h1>Video Transcript to HTML Converter</h1>

	<form onsubmit="return false;" class="inputs">
		<textarea id="transcript" placeholder="Paste transcript text here..."></textarea>
		<div class="flexcol">
			<div>
				<label for="videoUrl">Video URL for Links</label>
				<input type="url" id="videoUrl" placeholder="Optional video URL (adds timestamp links)">
			</div>
			<div>
				<label for="gapThreshold">Gap/Pause Threshold in Seconds</label>
				<input type="number" id="gapThreshold" value="" min="" step="5" placeholder="Optional Gap Detection">
			</div>
		</div>
	</form>

	<h2>Raw HTML</h2>
	<pre class="language-html"><code id="htmlOutput" class="language-html"></code></pre>

	<h2>Rendered HTML <span id="saveButtons"><button id="saveTxt">Save as .txt</button> <button id="saveHtml">Save as .html</button></span></h2>
	<div class="rendered" id="renderedOutput"></div>

	<script>
		// --- Utility: parse HH:MM:SS or MM:SS into seconds
		function timeToSeconds(ts) {
			const parts = ts.split(":").map(Number);
			if (parts.length === 2) {
				// MM:SS
				return parts[0] * 60 + parts[1];
			} else if (parts.length === 3) {
				// HH:MM:SS
				return parts[0] * 3600 + parts[1] * 60 + parts[2];
			}
			return 0;
		}

		function convertTranscript(text, videoUrl, gapThreshold = 30) {
			const lines = text.trim().split(/\r?\n/);
			let output = "";
			let currentTime = "";
			let currentParagraph = "";
			let expectContinuation = false;
			let lastSeconds = null;   // track last timestamp in seconds

			for (let rawLine of lines) {
				let line = rawLine.trim();

				if (/^\d{1,2}:\d{2}(?::\d{2})?$/.test(line)) {
					// Normalize timestamp to HH:MM:SS
					let parts = line.split(":");
					if (parts.length === 2) {
						line = "00:" + line;
					}
					const thisSeconds = timeToSeconds(line);

					// If we already have a paragraph in progress AND not expecting continuation
					if (currentParagraph && !expectContinuation) {
						const timeHtml = makeTimeElement(currentTime, videoUrl);
						output += `<p>${timeHtml} ${currentParagraph}</p>\n`;

						// Check gap AFTER writing the paragraph
						if (
							gapThreshold !== null &&
							lastSeconds !== null &&
							thisSeconds - lastSeconds > gapThreshold
						) {
							output += `<h2>${gapThreshold} second+ gap</h2>\n`;
						}

						currentParagraph = "";
					}

					currentTime = line;
					lastSeconds = thisSeconds;
				}else {
					currentParagraph += (currentParagraph === "" ? "" : " ") + line;
					expectContinuation = !/[.!?]["')]*$/.test(line);
				}
			}

			if (currentParagraph) {
				const timeHtml = makeTimeElement(currentTime, videoUrl);
				output += `<p>${timeHtml} ${currentParagraph}</p>\n`;
			}

			return output;
		}

		function makeTimeElement(ts, videoUrl) {
			if (!videoUrl) {
				return `<time datetime="${ts}">${ts}</time>`;
			}
			const seconds = timeToSeconds(ts);
			const url = videoUrl.includes("?") ? `${videoUrl}&t=${seconds}` : `${videoUrl}?t=${seconds}`;
			return `<a href="${url}" target="_blank"><time datetime="${ts}">${ts}</time></a>`;
		}

		function updateOutput() {
			const text = document.getElementById("transcript").value;
			const videoUrl = document.getElementById("videoUrl").value.trim();
			const rawGap = document.getElementById("gapThreshold").value.trim();

			// if empty, disable gap detection
			const gapThreshold = rawGap === "" ? null : parseInt(rawGap, 10);
			const output = convertTranscript(text, videoUrl, gapThreshold);
			const codeEl = document.getElementById("htmlOutput");
			codeEl.textContent = output;
			Prism.highlightAll();
			document.getElementById("renderedOutput").innerHTML = output;

			// show save buttons
			const renderedOutput = document.getElementById('renderedOutput');
			const button = document.getElementById('myButton');

			if (renderedOutput.innerHTML.trim() !== "") {
			  saveButtons.style.display = "inline-flex"; // Show the save buttons
			} else {
			  saveButtons.style.display = "none"; // Hide them
			}
		}

		// Update on input
		document.getElementById("transcript").addEventListener("input", updateOutput);
		document.getElementById("videoUrl").addEventListener("input", updateOutput);
		document.getElementById("gapThreshold").addEventListener("input", updateOutput);

		// function to save rendered output as a file
		function downloadFile(filename, content, type = "text/plain") {
			const blob = new Blob([content], { type });
			const url = URL.createObjectURL(blob);

			const a = document.createElement("a");
			a.href = url;
			a.download = filename;
			a.click();

			URL.revokeObjectURL(url);
		}

		document.getElementById("saveTxt").addEventListener("click", () => {
			const content = document.getElementById("renderedOutput").innerText;
			downloadFile("transcript.txt", content, "text/plain");
		});

		document.getElementById("saveHtml").addEventListener("click", () => {
			const content = document.getElementById("renderedOutput").innerHTML;
			const wrapped = `<!DOCTYPE html>
		<html lang="en">
		<head>
		<meta charset="UTF-8">
		<title>Transcript</title>
		</head>
		<body>
		${content}
		</body>
		</html>`;
			downloadFile("transcript.html", wrapped, "text/html");
		});


	</script>
	<!-- code syntax highlighting https://prismjs.com -->
	<link rel="stylesheet" href="prism.css" />
	<script src="prism.js"></script>
	<style>
		h2{
			display: flex;
			gap: 1rem;

			span{
				display:none;
				display: inline-flex;
				gap: inherit;
				border: 1px solid red;
			}
		}
		.inputs,
		pre {
			height: 25vh;
		}

		.inputs {
			display: flex;
			align-items: flex-start;
			gap: 1rem;

			textarea {
				align-self: normal;
				width: 100%;
			}

			input[type="url"] {
				width: auto;
				max-width: 80ch;
			}
			.flexcol{
				display: flex;
				flex-direction: column;
				gap: 1rem;
			}
			label{
				display:block;
			}
		}
		#saveButtons{display: none;}

		/*pre { background: #f5f5f5; padding: 1em; white-space: pre-wrap; }*/
		.rendered {
			margin: 0 auto;
			width: 100ch;
			font-size: calc(100% + .125vw);
			line-height: 1.5;
			word-spacing: 0.16em;

			time {
				font-weight: bold;
			}
		}
	</style>
</body>
</html>
